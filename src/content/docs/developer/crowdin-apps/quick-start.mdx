---
title: Quick Start
description: Learn how to build a Crowdin Application using Node.js
slug: developer/crowdin-apps-quick-start
---

import { Steps, Aside, CardGrid, LinkCard, Tabs, TabItem } from '@astrojs/starlight/components';

In this article, you'll learn the basic principles of building a Crowdin Application using Node.js and the Vercel platform. You'll build and deploy a sample app using Next.js along the way.

**Prerequisites**:

* Installed [Node.js (version 18 or later)](https://nodejs.org/en/download/) and npm or pnpm.
* Registered account on [Vercel](https://vercel.com/) with access to GitHub or another Git provider.
* Crowdin account with permissions to create and install apps.
* Created [OAuth application](/developer/authorizing-oauth-apps/) in Crowdin with `Client ID` and `Client Secret` values. These credentials will be used for authentication.

## Setup

In this step, download the sample app to your local machine and set up your development environment.

Clone the repository:

```bash
git clone https://github.com/crowdin/apps-quick-start-vercel.git
cd apps-quick-start-vercel
````

Install the required dependencies:

<Tabs syncKey="pkgManager">
  <TabItem label="npm">

```bash
npm install
```

  </TabItem>
  <TabItem label="pnpm">

```bash
pnpm install
```

  </TabItem>
</Tabs>

Copy the example environment file:

```bash
cp .env.example .env.local
```

Open the `.env.local` file and update it with your app credentials:

```env title=".env.local"
# Where your app runs locally
NEXT_PUBLIC_BASE_URL=http://localhost:3000

# Credentials from Crowdin OAuth app
CROWDIN_CLIENT_ID=<your-client-id>
CROWDIN_CLIENT_SECRET=<your-client-secret>

# Crowdin OAuth endpoint
AUTH_URL=https://accounts.crowdin.com/oauth/token

# Crowdin Apps iframe script (CDN)
NEXT_PUBLIC_CROWDIN_IFRAME_SRC=https://cdn.crowdin.com/widget/v1/crowdin-apps.min.js
```

Start the development server:

<Tabs syncKey="devCommand">
  <TabItem label="npm">

```bash
npm run dev
```

  </TabItem>
  <TabItem label="pnpm">

```bash
pnpm dev
```

  </TabItem>
</Tabs>

Once the app is running, open `http://localhost:3000` in your browser. You should see the app welcome page.

At this point, you have a working app with the following structure:

* `app/manifest.json/route.ts` – Serves the app manifest dynamically.
* `app/project-menu/page.tsx` – The Project Menu module loaded inside Crowdin.
* `app/events/[slug]/route.ts` – Handles `installed` and `uninstall` webhooks.
* `lib/fileProcessing.ts` – Logic for parsing and building custom file formats.
* `lib/FilePreview.tsx` – Generates a preview for translators inside Crowdin.
* `prisma/schema.prisma` – Defines the data model used for storing organization credentials.
* `middleware.ts` – Validates JWT tokens from Crowdin to authorize requests.

In the current state, the app includes only the **Project Menu** module and does not yet require authentication. You’ll add OAuth and custom file format support in the next steps.

<Aside type="tip" title="Interested in developing Crowdin Apps?">
  Check out our [Crowdin Apps SDK](https://crowdin.github.io/app-project-module/) to create apps in just a few lines of code.
</Aside>

## App Manifest

In this step, you’ll review the app manifest that describes your Crowdin App and defines how it integrates with the Crowdin interface.

The manifest is served dynamically using a dedicated route located at `app/manifest.json/route.ts`. This file returns the required metadata about your app.

```ts title="app/manifest.json/route.ts"
export async function GET() {
  const manifestData = {
    identifier: "getting-started",
    name: "Getting Started",
    baseUrl: process.env.NEXT_PUBLIC_BASE_URL,
    authentication: {
      type: "crowdin_app",
      clientId: process.env.CROWDIN_CLIENT_ID,
    },
    modules: {
      "project-menu": [
        { key: "menu", name: "Getting Started", url: "/project-menu" }
      ],
      "custom-file-format": [
        {
          key: "custom-file-format",
          type: "custom-file-format",
          url: "/api/file/process",
          signaturePatterns: {
            fileName: ".+\\.json$",
            fileContent: "\"hello_world\":",
          },
        },
      ],
    },
  };
  return NextResponse.json(manifestData);
}
```

### Manifest Highlights

* **baseUrl** – The root domain where your app is deployed. Crowdin uses this value to construct URLs for iframe modules and API calls. When deployed to Vercel, the production domain is injected automatically.
* **authentication** – Specifies that the app uses Crowdin App authentication based on the OAuth flow.
* **modules**:
  * `project-menu` – Adds a new tab inside Crowdin projects. When clicked, it opens the `/project-menu` route of your app inside an iframe.
  * `custom-file-format` – Registers support for JSON files containing the `"hello_world"` key. Crowdin sends the file contents to your `/api/file/process` route for parsing and building translations.

Once the app is deployed, the manifest will be available at the following URL:

```
https://<your-project-name>.vercel.app/manifest.json
```

You’ll use this URL in the **Install from URL** dialog when installing the app in your Crowdin account later in this guide.

## Deploying the App

In this step, you'll deploy the app to the Vercel platform and obtain the production URL that will be used as the app's `baseUrl`.

To deploy the app, follow these steps:

<Steps>
  1. Push the app code to a GitHub repository.
  2. Log in to [Vercel](https://vercel.com/) and select **Import Git Repository**.
  3. Choose your repository and proceed with the setup.
  4. In the **Environment Variables** section, add the variables from your `.env.local` file:
      - `CROWDIN_CLIENT_ID`
      - `CROWDIN_CLIENT_SECRET`
      - `NEXT_PUBLIC_BASE_URL` – set to your future production URL, e.g., `https://<project-name>.vercel.app`
      - `AUTH_URL` – `https://accounts.crowdin.com/oauth/token`
      - `NEXT_PUBLIC_CROWDIN_IFRAME_SRC` – `https://cdn.crowdin.com/widget/v1/crowdin-apps.min.js`
  5. Click **Deploy**.
</Steps>

Once deployed, Vercel will assign a production URL to your app. This URL will be used as the `baseUrl` in your manifest, as described in the previous step.
You’ll use it shortly to install the app in your Crowdin account.

<Aside type="note" title="Edge Function Support">
  The manifest is served through the Next.js App Router and runs as an Edge Function on Vercel. No additional configuration is required.
</Aside>

## Installing the App in Crowdin

Once your app is deployed, you can install it in your Crowdin account using the [manual installation](/developer/crowdin-apps-installation/) method.

Use the production manifest URL from your deployed Vercel app, for example:

```
https://<project-name>.vercel.app/manifest.json
```

After installation, a new tab called **Getting Started** will appear in your project navigation. If the app welcome page opens successfully, the app was installed correctly.

## Adding API Access

This section is optional and applies if you want your app to access the Crowdin API on behalf of the user or organization.

### Setting Up the Database with Prisma

To securely store organization credentials received during app installation, you'll need a database. This step uses [Prisma](https://www.prisma.io/) as an ORM. You can use SQLite for local development or switch to PostgreSQL or another provider for production.

The data model is defined in `prisma/schema.prisma` and includes a single `Organization` model:

```prisma title="prisma/schema.prisma"
model Organization {
  id                 String  @id @default(cuid())
  organizationId     Int
  userId             Int
  domain             String
  baseUrl            String
  appId              String
  appSecret          String
  accessToken        String?
  accessTokenExpires Int?
}
```

To apply the schema and generate the local database, run the following command:

```bash
npx prisma migrate dev --name init
```

This command creates a local SQLite database (or another provider if configured) and generates the required Prisma client.

At this point, your app is ready to store and retrieve installation data. In the next step, you’ll configure routes to handle `installed` and `uninstall` events from Crowdin.

### Handling Install and Uninstall Events

When a Crowdin App is installed or uninstalled, Crowdin sends a signed `POST` request to the app’s backend. You’ll now create a dynamic route that handles both events.

The handler is located in `app/events/[slug]/route.ts`. Based on the route parameter, it processes either the `installed` or `uninstall` event:

```ts title="app/events/[slug]/route.ts"
export async function POST(request: NextRequest, { params }: Params) {
  const event = params.slug; // "installed" | "uninstall"
  const body = await request.json();

  switch (event) {
    case 'installed':
      await prisma.organization.create({
        data: {
          id: nanoid(),
          organizationId: body.context.organization_id,
          domain: body.domain,
          appId: body.app.id,
          appSecret: body.app.secret,
          userId: body.context.user_id,
          baseUrl: body.baseUrl,
        },
      });
      break;
    case 'uninstall':
      await prisma.organization.delete({
        where: { organizationId: body.context.organization_id },
      });
      break;
  }
  return NextResponse.json({ ok: true });
}
```

This logic does the following:

* On `installed`, saves the organization and app credentials to the database.
* On `uninstall`, removes the organization entry.

To activate these handlers, update your app manifest by adding the following `events` block:

```json title="Manifest excerpt"
"events": {
  "installed": "/events/installed",
  "uninstall": "/events/uninstall"
}
```

After these changes, Crowdin will call the specified routes during app installation and removal.

### Adding JWT Middleware

When a Crowdin App is opened inside a project, Crowdin includes a signed JWT token in the request. To verify the token and extract user context, you’ll add middleware to your app.

Create the `middleware.ts` file in the root of your project and add the following code:

```ts title="middleware.ts"
import { jwtVerify } from 'jose';
import { NextRequest, NextResponse } from 'next/server';

export async function middleware(request: NextRequest) {
  if (!request.nextUrl.pathname.startsWith('/api')) return NextResponse.next();

  const token =
    request.headers.get('Authorization')?.replace('Bearer ', '') ||
    request.nextUrl.searchParams.get('jwtToken');

  if (!token) {
    return NextResponse.json(
      { error: { message: 'No token' } },
      { status: 401 }
    );
  }

  try {
    const { payload } = await jwtVerify(
      token,
      new TextEncoder().encode(process.env.CROWDIN_CLIENT_SECRET!)
    );

    const headers = new Headers(request.headers);
    headers.set('x-decoded-jwt', JSON.stringify(payload));

    return NextResponse.next({ request: { headers } });
  } catch (error) {
    return NextResponse.json(
      { error: { message: 'Invalid token' } },
      { status: 401 }
    );
  }
}
```

Next.js will automatically run this middleware for every request that matches a path defined in the `matcher` configuration.

Define the matcher at the end of the file:

```ts title="middleware.ts"
export const config = {
  matcher: [
    '/api/user/:path*',
    '/api/file/process/:path*',
    // add more protected routes here
  ],
};
```

This ensures that any sensitive route (such as user info or file processing) is only accessible if the token is present and valid.

### Creating the /api/user Route

You’ll now create a protected API route that returns information about the currently authenticated Crowdin user. This route uses the decoded JWT payload and the stored organization credentials to retrieve a valid access token and make an API request to Crowdin.

Create the `app/api/user/route.ts` file and add the following code:

```ts title="app/api/user/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getValidOrganizationToken } from '@/lib/token';
import { CrowdinApiClient } from '@crowdin/crowdin-api-client';

export async function GET(request: NextRequest) {
  const decoded = JSON.parse(request.headers.get('x-decoded-jwt') || '{}');

  const organization = await prisma.organization.findFirst({
    where: {
      domain: decoded.domain,
      organizationId: Number(decoded.context?.organization_id),
    },
  });

  if (!organization) {
    return NextResponse.json(
      { error: { message: 'Organization not found' } },
      { status: 404 }
    );
  }

  const accessToken = await getValidOrganizationToken(organization.id);

  const client = new CrowdinApiClient({ token: accessToken });
  const user = await client.usersApi.getAuthenticatedUser();

  return NextResponse.json(user.data);
}
```

This route performs the following:

* Reads the decoded JWT payload from the request headers
* Locates the organization by `domain` and `organizationId`
* Retrieves or refreshes the access token using a helper function
* Instantiates the Crowdin API client
* Returns the current user’s information as JSON

Make sure the `/api/user` route is included in your middleware matcher so it’s protected by the JWT verification logic:

```ts title="middleware.ts"
export const config = {
  matcher: [
    '/api/user/:path*',
    '/api/file/process/:path*',
    // add more secured routes here
  ],
};
```

You can now test the integration by opening your installed app in Crowdin and calling the `/api/user` route, for example by clicking a **Show User Details** button in your Project Menu module.

## Supporting a Custom File Format

This section is optional and applies if you want your app to process custom files uploaded to Crowdin. You'll configure the `custom-file-format` module in your manifest, define the processing route, and handle file parsing and preview generation on the backend.

By the end of this section, your app will:

- Detect and process `.json` files that contain a specific key (e.g. `"hello_world"`)
- Extract source strings and provide an HTML preview for translators
- Rebuild translated files for export from Crowdin

To implement this, follow the steps below.

### Defining the Module in the Manifest

To support processing custom files in Crowdin, define a `custom-file-format` module in your app manifest. In this example, the app will handle `.json` files that contain the `"hello_world"` key.

Add the following to the `modules` section of your manifest:

```json title="manifest.json excerpt"
"modules": {
  "custom-file-format": [
    {
      "key": "custom-file-format",
      "type": "custom-file-format",
      "url": "/api/file/process",
      "signaturePatterns": {
        "fileName": ".+\\.json$",
        "fileContent": "\"hello_world\":"
      }
    }
  ]
}
```

This configuration tells Crowdin:

* To send matching files to your app’s `/api/file/process` route
* To trigger this module only for `.json` files that include the key `"hello_world"`

Crowdin will send the file contents to your app when parsing or rebuilding the file during the import/export flow.

### Creating the File Processing Route

To handle file parsing and rebuilding, you'll create a backend route that responds to Crowdin's `POST` requests.
This route will distinguish between two job types: `parse-file` and `build-file`.

Create the following route file:

```ts title="app/api/file/process/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { handleParseFile, handleBuildFile } from '@/lib/fileProcessing';

export async function POST(req: NextRequest) {
  const body = await req.json();

  try {
    switch (body.jobType) {
      case 'parse-file':
        return await handleParseFile(body);
      case 'build-file':
        return await handleBuildFile(body);
      default:
        return NextResponse.json(
          { error: { message: 'Unknown job type' } },
          { status: 400 }
        );
    }
  } catch (error) {
    return NextResponse.json(
      { error: { message: 'Failed to process file' } },
      { status: 500 }
    );
  }
}
```

This route:

* Receives payloads from Crowdin when a file is uploaded or exported
* For `parse-file`, extracts source strings and builds a preview
* For `build-file`, injects translations into the original structure

In the next step, you'll implement the logic behind `handleParseFile` and `handleBuildFile` in a helper module.

### Implementing File Parsing and Rebuilding

Now you'll implement the logic behind the `handleParseFile` and `handleBuildFile` functions referenced in the `/api/file/process` route. These helpers extract strings from uploaded files, generate a preview, and rebuild translated files during export.

Create the following helper file:

```ts title="lib/fileProcessing.ts"
import { generatePreviewHtml } from './preview';
import { getContent, getStringsForExport, getTranslation } from './fileUtils';

export async function handleParseFile(req: ParseFileRequest) {
  const content = await getContent(req.file);

  const sourceStrings = [];
  const previewStrings: Record<string, { text: string; id: number }> = {};

  let index = 0;

  for (const key of Object.keys(content)) {
    if (typeof content[key] !== 'string') continue;

    sourceStrings.push({
      identifier: key,
      context: `Key: ${key}`,
      text: content[key],
      previewId: index,
    });

    previewStrings[key] = {
      text: content[key],
      id: index,
    };

    index++;
  }

  const previewHtml = await generatePreviewHtml(req.file.name, previewStrings);

  return {
    data: {
      strings: sourceStrings,
      preview: Buffer.from(previewHtml).toString('base64'),
    },
  };
}

export async function handleBuildFile(req: BuildFileRequest) {
  const content = await getContent(req.file);
  const translations = await getStringsForExport(req);
  const languageId = req.targetLanguages[0].id;

  for (const key of Object.keys(content)) {
    if (typeof content[key] !== 'string') continue;

    content[key] = getTranslation(translations, key, languageId, content[key]);
  }

  return {
    data: {
      content: Buffer.from(JSON.stringify(content, null, 2)).toString('base64'),
    },
  };
}
```

This helper file exports two main functions:

* `handleParseFile` – Extracts translatable strings and generates an HTML preview
* `handleBuildFile` – Reconstructs the final translated file using strings from Crowdin

These functions rely on utilities for reading file content, formatting translations, and generating HTML. You'll implement those next.

### Creating Utility Helpers

This step implements the supporting functions used for parsing file content, generating previews, and preparing files for download or export. These helpers are referenced by `handleParseFile` and `handleBuildFile`.

Create a file named `lib/fileUtils.ts` with the following code:

```ts title="lib/fileUtils.ts"
import got from 'got';

export async function getContent(file: any) {
  if (file.content) {
    return JSON.parse(Buffer.from(file.content, 'base64').toString());
  }

  return (await got(file.contentUrl, { responseType: 'json' })).body;
}

export function getTranslation(translations: any[], stringId: string, languageId: string, fallback: string) {
  const match = translations.find((t) => t.identifier === stringId);
  return match?.translations?.[languageId]?.text || fallback;
}

export async function getStringsForExport(req: any) {
  if (req.strings) return req.strings;

  if (req.stringsUrl) {
    return (await got(req.stringsUrl, { responseType: 'json' })).body;
  }

  throw new Error('No strings found in request');
}
```

Next, create a file named `lib/preview.ts` to render an HTML preview from extracted strings:

```ts title="lib/preview.ts"
import ReactDOMServer from 'react-dom/server';
import FilePreview from './FilePreview';

export async function generatePreviewHtml(fileName: string, strings: Record<string, any>) {
  return ReactDOMServer.renderToStaticMarkup(
    FilePreview({ fileName, strings })
  );
}
```

And create the corresponding React component to render a simple HTML preview:

```tsx title="lib/FilePreview.tsx"
export default function FilePreview({ fileName, strings }: { fileName: string; strings: Record<string, any> }) {
  return (
    <html>
      <body>
        <h1>{fileName}</h1>
        <ul>
          {Object.entries(strings).map(([key, { text, id }]) => (
            <li key={id}><strong>{key}</strong>: {text}</li>
          ))}
        </ul>
      </body>
    </html>
  );
}
```

These helpers let your app:

* Read the uploaded file's content
* Find the right translations for export
* Generate an inline preview using React
* Return a static HTML preview to display inside Crowdin

In the next step, you'll optionally add support for large file handling using blob storage.

### Handling Large Files with Blob Storage

If the processed file data (either strings or preview HTML) exceeds Crowdin’s inline payload size limit (around 5 MB), your app should upload the content to a temporary location and return a download link instead.

Create the following helper function:

```ts title="lib/blobUpload.ts"
export async function uploadToBlob(content: string | Buffer, key: string, mime: string) {
  const res = await fetch('https://api.vercel.com/v2/blob', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/octet-stream',
      'x-vercel-filename': key,
    },
    body: typeof content === 'string' ? Buffer.from(content) : content,
  });

  const { url } = await res.json();
  return url as string;
}
```

Then update your `handleParseFile` and `handleBuildFile` logic to use this helper when needed. For example:

```ts
if (Buffer.byteLength(previewHtml, 'utf8') > 5 * 1024 * 1024) {
  const previewUrl = await uploadToBlob(previewHtml, 'preview.html', 'text/html');
  return {
    data: {
      strings: sourceStrings,
      previewUrl,
    },
  };
}
```

This ensures compatibility with larger files while maintaining Crowdin’s required response structure. Crowdin will download the file from the provided URL and process it as if it were inline.

### Testing the Custom File Format Implementation

To verify that your custom file format module is working correctly, upload a test file to any Crowdin project where your app is installed.

Use the following example content:

```json
{
  "hello_world": "Hello World!",
  "test": "This is a sample string for translation"
}
```

Save this content to a `.json` file on your local machine (e.g. `sample.json`). Then, open your test project in Crowdin and upload the file via **Sources > Files**.

Crowdin will detect that the file matches your custom-file-format signature and send it to your app’s `/api/file/process` route. If everything is set up correctly:

* The **file will be parsed**, and two source strings will appear in the Editor.
* The **left-side preview panel** will display a rendered HTML view using your app’s preview template.

If the file content is large, Crowdin will download the preview from your app’s `previewUrl` instead of using inline data.

## Updating the App Base URL

If your app’s domain changes after it has been installed in Crowdin (for example, after moving from a staging to production environment), you’ll need to update the `baseUrl` and reinstall the app.

Crowdin caches the `baseUrl` from the manifest at the time of installation. Updating the environment variable alone is not enough—Crowdin won’t re-read it until you reinstall the app.

To update the deployment domain:

<Steps>
  1. Set the new value in your hosting environment (e.g. `NEXT_PUBLIC_BASE_URL=https://your-new-domain.vercel.app`).
  2. Redeploy your app to apply the change.
  3. Open your manifest URL in the browser and confirm that `baseUrl` reflects the new domain.
  4. In Crowdin, go to **Account Settings > Crowdin Applications**.
  5. Remove the old version of the app.
  6. Reinstall the app using the updated manifest URL.
</Steps>

After reinstalling, Crowdin will use the updated domain for iframe modules and event delivery.

## See Also

<CardGrid>
  <LinkCard
    title="Crowdin JS SDK"
    description="Helpers for Crowdin iframe apps."
    href="https://github.com/crowdin/apps-helpers"
    target="_blank"
  />
  <LinkCard
    title="Environment Variables in Vercel"
    description="Define and manage variables in Vercel projects."
    href="https://vercel.com/docs/configuration/project/environment-variables"
    target="_blank"
  />
  <LinkCard
    title="Next.js App Router"
    description="Docs for the App Router in Next.js 13+."
    href="https://nextjs.org/docs/app/building-your-application/routing"
    target="_blank"
  />
</CardGrid>
